# 309. 最佳买卖股票时机含冷冻期

给定一个整数数组，其中第 `i` 个元素代表了第 `i` 天的股票价格 。​

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

* 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
* 卖出股票后，你无法在第二天买入股票 (即冷冻期为 `1` 天)。

**示例:**  
>**输入:** [1,2,3,0,2]  
>**输出:** 3  
>**解释:** 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]

---
**解法一：动态规划**  
思路：  

**状态表示及转移:**

* $dp[i][j]$ 表示第 `i` 天，持有股票的状态。$dp[i][1]$表示持有股票。
* $dp[i][0]$ 表示第 `i` 天未持有股票。
  1. 它可能是第 $i-1$ 天持有股票，然后第 $i$ 天卖出去了，所以 $dp[i][0] = dp[i-1][1] + price[i]$;
  2. 也可能是第 $i-1$ 天未有股票，第 `i` 天没有买入，所以 $dp[i][0] = dp[i-1][0]$;
  3. 最后对二者取最大，即 $dp[i][0] = max(dp[i-1][1] + price[i], dp[i-1][0])$;
* $dp[i][1]$ 表示第 `i` 天持有股票
  1. 它可能是第 $i-1$ 天就持有股票，然后第 $i$ 天没有卖出（也就是在第 $i$ 天啥也没干），所以 $dp[i][1] = dp[i-1][1]$;
  2. 也可能是第 $i-2$ 天未有股票，然后第 $i$ 天买入，所以 $dp[i][1] = dp[i-2][0] + price[i]$;
  3. 最后对二者取最大，即 $dp[i][0] = max(dp[i-1][1], dp[i-2][0] + price[i])$;

```Java
class Solution {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        if (len < 2) return 0;

        //x表示本不持有，y表示持有，z表示当天卖出，不持有
        //第一天若持有，则收益为负；不持有则收益为零
        int x = 0, y = -prices[0], z = 0;
        // int[][] dp = new int[len][3];
        // dp[0][1] = -prices[0];

        for (int i = 1; i < len; i++) {
            y = Math.max(y, x - prices[i]);
            //dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            //当天的本不持有可以由前一天本不持有或前一天卖出得到

            x = Math.max(x, z);
            //dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][2]);
            //当天的持有可以由前一天的持有或前一天的本不持有-当天的股票价格得到, 即买进一只股票

            z = y + prices[i];
            //dp[i][2] = dp[i - 1][1] + prices[i];
            //当天卖出可以由前一天的持有+当天的股票价格得到, 即卖出手中的股票
        }
        //返回最后一天不持有股票的状态，此处可以得到收益的最大值
        return Math.max(x, z);
    }
}
```

**复杂度分析：**  

* 时间复杂度：$O(n)$，其中 $n$ 为数组 ${\it prices}$ 的长度。
* 空间复杂度：$O(1)$，我们需要 $3n$ 的空间存储动态规划中的所有状态，对应的空间复杂度为 $O(n)$。如果使用空间优化，空间复杂度可以优化至 $O(1)$。

# 1014. 最佳观光组合

给定正整数数组 `A，A[i]` 表示第 `i` 个观光景点的评分，并且两个景点 `i` 和 `j` 之间的距离为 `j - i`。

一对景点`（i < j）`组成的观光组合的得分为`（A[i] + A[j] + i - j）：`景点的评分之和减去它们两者之间的距离。

返回一对观光景点能取得的最高分。

**示例：**
>**输入：** [8,1,5,2,6]  
>**输出：** 11  
>**解释：** 输入不存在公共前缀。

**提示：**

1. `2 <= A.length <= 50000`
2. `1 <= A[i] <= 1000`

---
**解法一：**  
思路：  

* 观察观光组合的得分为`（A[i] + A[j] + i - j）`，抽象成 `f(i) = A[i] + i, f(j) = A[j] - j`，整个过程相当于遍历 `max(f(i)) + f(j)` 再求最大值。
* 那么就可以通过一个变量 `sum` 保存 `max(f(i))` 的值，可以证明只需要遍历一遍就能覆盖所有情况。

```Java
class Solution {
    public int maxScoreSightseeingPair(int[] A) {
        int max = 0, sum = A[0] + 0;
        for (int j = 1; j < A.length; ++j) {
            max = Math.max(max, sum + A[j] - j);
            sum = Math.max(sum, A[j] + j);
        }
        return max;
    }
}
```

**复杂度分析：**  

* 时间复杂度：$O(N)$，其中 $n$ 为数组 $A$ 的大小。我们只需要遍历一遍数组即可。
* 空间复杂度：$O(1)$，我们只需要常数空间来存放若干变量。

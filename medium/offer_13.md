### 面试题13. 机器人的运动范围


地上有一个 `m` 行 `n` 列的方格，从坐标 `[0,0]` 到坐标 `[m-1,n-1]` 。一个机器人从坐标 `[0, 0]` 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于 `k` 的格子。  
例如，当 `k` 为 `18` 时，机器人能够进入方格 `[35, 37]` ，因为 `3+5+3+7=18`。但它不能进入方格 `[35, 38]`，因为 `3+5+3+8=19`。请问该机器人能够到达多少个格子？

**示例 1:**  
>**输入:** m = 2, n = 3, k = 1  
>**输出:** 3


**示例 2:**  
>**输入:** m = 3, n = 1, k = 0  
>**输出:** 0

**提示：**

* `1 <= n,m <= 100`
* `0 <= k <= 20`


     
**解法一：深度优先遍历 DFS**
思路：  
* 深度优先搜索： 可以理解为暴力法模拟机器人在矩阵中的所有路径。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。
* 剪枝： 在搜索中，遇到数位和超出目标值、此元素已访问，则应立即返回，称之为 `可行性剪枝` 。

**算法解析**
* 终止条件： 当 ① 行列索引越界 或 ② 数位和超出目标值 k 或 ③ 当前元素已访问过 时，返回 0 ，代表不计入可达解。
* 递推工作：
    1. 标记当前单元格 ：将索引 `(i, j)` 存入 Set `visited` 中，代表此单元格已被访问过。
    2. 搜索下一单元格： 计算当前元素的 **下、右** 两个方向元素的数位和，并开启下层递归 。
* 回溯返回值： 返回 `1 + 右方搜索的可达解总数 + 下方搜索的可达解总数`，代表从本单元格递归搜索的可达解总数。

```Java   
class Solution {
    boolean[][] visited;
    public int movingCount(int m, int n, int k) {
        // 存储已被访问过格子
        visited = new boolean[m][n];
        return dfs(0,0,m,n,k);
    }
    // 深度优先搜索
    private int dfs(int x, int y, int m, int n, int k) {
        // 在搜索中，遇到数位和超出目标值、此元素已访问，则应立即返回
        if (x >= m || y >= n || visited[x][y] ||  (x % 10 + x / 10 + y % 10 + y / 10) > k) return 0;
        visited[x][y] = true;
        return 1 + dfs(x + 1, y, m, n, k) + dfs(x, y + 1, m, n, k);
    }
}

```

**复杂度分析：**  
* 时间复杂度：$O(MN)$，其中 `m` 为方格的行数，`n` 为方格的列数。考虑所有格子都能进入，那么搜索的时候一个格子最多会被访问的次数为常数，所以时间复杂度为 $O(2mn)=O(mn)$。
* 空间复杂度：$O(MN)$，其中 `m` 为方格的行数，`n` 为方格的列数。搜索的时候需要一个大小为 $O(mn)$ 的标记结构用来标记每个格子是否被走过。
